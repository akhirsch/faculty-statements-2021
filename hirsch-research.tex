\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[letterpaper, margin=1in, bottom=1in]{geometry}
\usepackage[numbers,sort,square]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bbold}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{latex-pl-syntax/pl-syntax}
\usepackage{xspace}
\usepackage{suffix}
\usepackage{turnstile}
\usepackage{multicol}

\usepackage[hidelinks]{hyperref}


% Notes
\newcommand{\uncertain}[1]{{\color{red} #1}\xspace}
\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\newcommenter{\akh}{purple}{AKH}

% AMSTHM Setup
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}
\newtheorem{inv}{Invariant}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

\author{Andrew K. Hirsch}
\title{Research Statement}
\date{}

\bibliographystyle{plainnat}

\begin{document}

\maketitle

\textbf{My work focuses on the semantics and design of programming languages and logics for writing and verifying decentralized software.}
Thus, my work allows programmers to write and reason about programs with components that may be mutually-distrusting, represent different threads of computation, represent different nodes in a distributed system, or more.
To do this, I treat trust and communication as explicit parts of the design process, rather than afterthoughts.
I then keep to a key design principle: communication can only happen along trust lines.
This allows us to prove that programs and proofs are \emph{correct by construction}: communication never leaks secrets, nor does it derail computation.

My particular work in this space breaks down into three lines.
First, I build logics for modeling security policies where \textbf{trust is a first-class citizen}.
Treating trust as something which can be manipulated by the logic itself allows us to model more-realistic security policies, but makes the metatheory much more difficult to develop.
Second, I develop \textbf{new semantic foundations for language-based security}, which allows us to build a toolbox for \emph{designers} of such languages.
Language designers often have to prove theorems---such as \emph{noninterference}, the main security theorem for information-security policies---over and over again.
By taking advantage of semantic techniques, we can prove such theorems once, and then apply it to a new language by noting what language features it has, and which it does not have.
Finally, I work on \textbf{functional-concurrent deadlock-free-by-construction concurrent programming}.
This allows a programmer to program in a familiar functional style and extract out several programs---which can be used, for example, as a distributed system---which provably communicate without going wrong.

Not only is my work unified by motivations involving decentralization, communication, and trust, it also shares a foundational technical core: \emph{modal logic}.
In my work, I represent decentralized software components using \emph{modalities}.
This allows me to bring decades of work on the semantics and proof theory of modal logic to bear on the problems of decentralized software.
Moreover, modalities allow for an easy representation of communication: communication moves information from one modality (i.e., component) to another.

In another line of work, I also use modalities to represent \textbf{computational effects}, which are ways that programs interact with their environment other than receiving inputs and producing outputs.
In particular, I have used modalities to show that \textbf{strict and lazy evaluation strategies arise from effect interactions.}

\section*{Trust as a First-Class Citizen}



\section*{Semantic Tools for Information-Security Policies}

\section*{Deadlock-Free-By-Construction Higher-Order Programming}

\section*{Strictness and Laziness from Effects}

\section*{Future Work}


\bibliography{bibliography/main}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
