\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper, top=0cm, margin=2cm, bottom=2cm]{geometry}
\usepackage[numbers,sort&compress,square]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bbold}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{pl-syntax}
\usepackage{xspace}
\usepackage{suffix}
\usepackage{turnstile}
\usepackage{multicol}

\usepackage[hidelinks]{hyperref}


% Notes
\newcommand{\uncertain}[1]{{\color{red} #1}\xspace}
\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\newcommenter{\akh}{purple}{AKH}

% AMSTHM Setup
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}
\newtheorem{inv}{Invariant}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

\author{Andrew K. Hirsch}
\title{Research Statement}
\date{}

\bibliographystyle{plainnat}

\begin{document}

\maketitle

\textbf{My work focuses on the semantics and design of programming languages and logics for writing and verifying decentralized software~\citep{SilverHHCZ22,MenzHLG22,HirschG22,HirschC21,HirschACAT20,HirschT18,HirschC13}.}
Thus, my work allows programmers to write and reason about programs with components that may be mutually distrusting, represent different threads of computation, represent different nodes in a distributed system, or more.
My general approach is to include trust and communications as explicit primitives in the higher-order languages that I design.
I abide by a key design principle: communication can only happen along trust lines.
This allows us to prove that programs and proofs are \emph{correct by construction}: communication never leaks secrets, nor does it cause errors such as deadlock.

My research in this space can be divided into three lines.
First, I have designed logics with \textbf{trust as a first-class citizen} to state and reason about security policies.
Treating trust as something which can be manipulated in the specifications themselves allows us to model more-realistic security policies, but makes the metatheory much more difficult to develop.
Second, I have developed \textbf{new semantic foundations for language-based security}, which can be seen as a toolbox for \emph{designers} of such languages.
Language designers often have to prove theorems---such as \emph{noninterference}, the main security theorem for information-security policies---over and over again.
By taking advantage of semantic techniques, we can prove such theorems once, and then apply them to a new language by noting what language features it has and does not have.
Finally, I am working on \textbf{functional-concurrent deadlock-free-by-construction concurrent programming}.
This allows a programmer to program in a familiar functional style and extract out several programs---for example, on program for each node in a distributed system---which provably communicate without going wrong.

Not only is my work unified by motivations involving decentralization, communication, and trust, it also shares a foundational technical core: \emph{modal logic}.
In my work, I represent different decentralized software components using \emph{modalities of truth}, a concept which goes back at least to Aristotle and which had been used extensively by the logic and computer-science communities since the 1960s.
This allows me to bring decades of work on the semantics and proof theory of modal logic to bear on the problems of decentralized software.

\iffalse
In another line of work, I also use modalities to represent \emph{computational effects}, which are ways that programs interact with their environment other than receiving inputs and producing outputs.
In particular, I have used modalities to show that \textbf{evaluation order in programming languages can be explained by effect interactions.}
\fi

In the following three sections, I explain each of these lines of research in more detail.
In particular, I describe the research I have done in each line and how it has addressed important gaps in the research literature.

\section*{Trust as a First-Class Citizen in Logic}

Systems have certain resources that not every component should have access to.
For instance, a university system may have printers in the engineering library that engineering students, but not liberal-arts students, should be able to print on (and vice-versa).
Policies about what system components may access what resources are known as \emph{authorization} policies.
For instance, imagine a key-card access system for an apartment complex where users may fill any combination of three roles: residents, who may access their homes; staff, who may access the building they work in; and security auditors, who may see access logs.
Access logs map key-card--id numbers to building accesses, while security auditors are not allowed to know what key-card--id numbers are associated to what names.
An auditor, Alice, may see a card access both the building that her friend Bob works in and the building he lives in; she may then believe that number belongs to Bob.
Based on this, Alice may take certain actions; for instance, she may ignore when that key-card id accesses more buildings that she believes Bob should have access to.
However, perhaps Alice is mistaken: that key card is actually owned by Cathy, who happens to live and work in the same buildings as Bob.
If another guard, say Dave, trusts Alice, he will be willing to believe Alice when she tells him that the key-card id she mistakenly believes belongs to Bob should be able to access the building Cathy is accessing illegally.

Previous work used modalities to reason about \emph{beliefs} such as Alice's.
Combining modal logics with trust resulted in logics called \emph{authorization logics}.
Authorization logics have been successfully used not only to reason about authorization policies~\citep{Abadi06}, but also to enforce such policies~\cite{SchneiderWS11,SirerDBRSWWS11}.

While enforcing authorization policies using logic directly gives correct and performant security, doing so also breaks the assumptions used when arguing for the correctness of such logics.
These arguments rely on \emph{models} of the logic, which interpret statements in the logic as being true about some mathematical structure.
Because the systems now used logical formulae directly to represent beliefs, systems were no longer models for those logics, since models did not contain logical formulae.
In order to bridge this disconnect, I developed FOCAL---an authorization logic similar to that found in the Nexus operating system~\citep{SchneiderWS11,SirerDBRSWWS11}---and built a \emph{belief} semantics for it which did contain these formulae~\citep{HirschC13}.
Belief semantics inspired later work in models for social-network privacy policies~\cite{PardoS17}, while the design of FOCAL influenced the design of a later authorization logic used in software-defined networks~\citep{SkalkaRDKGDSF19}.

While FOCAL provided correctness arguments for practical authorization logics, no practical authorization logic was known to enjoy \emph{noninterference}, the main security theorem of authorization logics.
Intuitively, noninterference says that if a principal like Alice has some beliefs, they do not affect whether Bob, who does not trust her, believes.
However, when trust can be manipulated by logical connectives like disjunction and implication, knowing who trusts whom is highly-nontrivial.
When I designed FLAFOL~\citep{HirschACAT20}, which refined FOCAL with information-security policies, I adopted proof-theoretic techniques to state and prove noninterference even in the face of these difficulties.

While FLAFOL was a major step forward, it sacrificed other metatheoretic properties in order to make the proof of noninterference possible.
In my current work, I am adapting techniques from modal type theory to regain those metatheoretic properties, while also increasing the precision of the technique.

\section*{New Semantic Foundations for Language-Based Security}

Language-based security strives to build programming languages which enforce security guarantees in any program written in those languages.
Most commonly, they enforce information-security guarantees using \emph{information-flow control}; languages that implement information-flow control are called information-flow languages.
In their simplest form, these languages divide data into secret data and public data, and then ensure that secret data cannot affect an adversaries observations.
This property is known, yet again, as \emph{noninterference}, and it is closely related to noninterference in authorization logics.

While the history of information-flow control is long and complicated, almost all work in the area has focused on building languages for new settings.
In contrast, \textbf{my goal is to develop a semantic toolbox for the designers information-flow languages}.
In particular, I have built models of information-flow languages and exploited those models to prove general theorems that can apply to future languages.
This can make noninterference---along with other information-security guarantees---easier to prove in future works.

I have begun to build that toolbox in three ways.
First, by designing FLAFOL, an authorization logic which includes information-flow labels representing information-security policies on beliefs~\citep{HirschACAT20}.
Since authorization decisions are based on data which might be subject to information-security policies, care must be taken not to leak information about that data when enforcing authorization policies.
Authorization-policy enforcement corresponding to FLAFOL proofs is guaranteed to comply with these information-security policies, with no additional proof burden on the implementer.

Second, I provided a semantics of \emph{program-counter labels}, a common aspect of information-flow--control type systems, via a \emph{monadic} semantics of \emph{effects}~\citep{HirschC21}.
Noninterference arguments for languages that use program-counter labels are famously complicated.
My semantics enabled me to prove a theorem called \emph{noninterference half-off}.
This guarantee allows a language designer to use simpler proofs of noninterference for \emph{pure} languages---which do not need program-counter labels---by using the monadic semantics to reason about their effects instead.

% It feels weird and unethical to use "I" here---like I'm writing the students out of the story. I think that's standard practice, though?
Third, I provided a Coq library based on \emph{Interaction Trees} for implementing and reasoning about information-flow programming languages~\citep{SilverHHCZ22}.
Interaction trees represent possibly-nonterminating programs in Coq as trees of interactions with their environment, branching based on the possible responses from the environment.
The original interaction-trees library reasoned about interaction trees using \emph{bisimilarity}, which states that programs interact with their environment using the same pattern.
We added a \emph{indistinguishability} relationship, which tells us when an adversary cannot see a difference between programs via their interactions with their environments.
This allowed us to instantiate the indistinguishability model of information flow~\citep{SabelfeldS99}, and thus use the interaction-trees library to build simple proofs of noninterference.
In particular, we were able to show that a compiler preserved noninterference; formal proofs of secure compilation are an active area of current research.

In current work, I am working on building indistinguishability models of particular languages which combine functional programming with \emph{declassification} using logical relations~\citep{MenzHLG22}.
Declassification allows secret data to influence public data in certain cases; thus, noninterference is no longer an appropriate information-security guarantee.
Instead, more-subtle guarantees limit the influence private data can have on public.
By understanding what those more-subtle guarantees are and how they can be proven, I am stretching the limits of indistinguishability models.
Thus, while building models of particular languages does not result in theorems that can be applied to new languages, I hope to use the lessons learned from this work to build better general models in the future.

\section*{Deadlock-Free-By-Construction Higher-Order Programming}

So far we have focused on security aspects of decentralized programming.
However, decentralization also requires writing concurrent software, allowing code to be distributed between different processes or even computers.
I am particularly interested concurrent programs where processes communicate via messages, as happens at every level of concurrency, from distributed systems to modern processors.
Classically, message-passing concurrency has been studied via concurrency models such as $\pi$~calculus.
A major goal of these models is proving \emph{deadlock-freedom} of concurrent code---that is, that the different processes in the code never find themselves waiting on each other.

When writing concurrent software, care must be taken when choosing a programming model as well as a concurrency model.
Usually, software engineers prefer higher-order languages such as functional or object-oriented languages, since higher-order abstractions allow more and better-behaved code reuse.
Combining these features with features from concurrency models, however, makes deadlock-freedom even more difficult to reason about.
Much work uses increasingly-complicated \emph{session types} to tame communication~\citep{ScalasY19,HondaYC16}.
\emph{Choreographic programming} offers a promising alternative: instead of writing each process's code separately, we write one program for our entire system using an Alice-and-Bob--style notation~\citep{Montesi13}.
However, previous formal work only considered lower-order choreographic programming, which prevented serious code reuse.
Despite this, informal implementations of higher-order choreographic programming, via a language called Choral, found real-world use based partially on deadlock freedom~\citep{GiallorenzoMP20}.

I solved this problem when I designed Pirouette, the first functional choreographic language~\citep{HirschG22}.
Pirouette's design is parameterized over a single-process language; Pirouette messages are values in this language.
Moreover, I show how we can lift a type system for such a single-process language to a modal type system for Pirouette.
Here, modalities represent which process holds a value.

\emph{Endpoint projection} translates a Pirouette program into a program for each process.
This program is expressed in a standard concurrent $\lambda$ calculus---that is, a functional programming language with \textsf{send} and \textsf{receive} primitives.
While programs in this language can easily deadlock, Pirouette programs translate to deadlock-free code.
This guarantee, along with all of Pirouette's other guarantees, is formally proven in Coq.
The corresponding increase in confidence of these guarantees is especially important given that major theorems in concurrency theory have recently been disproved~\citep{Cruz-FilipeMP19}.

\iffalse
\section*{Strictness and Laziness from Effects}

When a function is called on an argument that is not a value, two things could happen.
Most languages are \emph{strict}, meaning they evaluate the argument first and then run the function on the resulting value.
However, some languages are \emph{lazy}, meaning they start running the function and evaluate the argument on demand.
Strict programs are much easier to reason about, leading to their near-universal adoption; however, laziness allows for speedups in some situations and allows programs to naturally operate on infinite data structures.
This choice, and the consequences of it, are some of the oldest topics in computer science, having interested luminaries such as Alonzo Church~\citep{ChurchR36}.
By adopting a new perspective on this old problem, I was able to both shed new light on the choice itself and discover insights into modern problems~\citep{HirschT18}.

I argue that strictness and laziness arise not when we think about function calls, but instead when we think about \emph{program composition}.
Moreover, it only comes when we try to compose programs with two effects: (possible) nontermination and (possible) \emph{nonlinearity}.
Nontermination can be given monadic semantics, since programs which may not terminate may not produce a value.
Nonlinearity is a stranger beast: a program uses its input \emph{nonlinearly} if it uses it any number of times other than exactly one.
Nonlinearity cannot be given monadic semantics, but instead must be given semantics using a \emph{comonad}, which changes an \emph{input} of a program rather than the output.

To see that you need both effects, let us imagine that we work with a linear language.
Then every program must use each of its inputs exactly once and so every input will be evaluated.
Thus, if any input does not terminate, the entire program does not terminate.
Dually, imagine that we work with a terminating language.
Then, whether or not a program uses its inputs, those inputs will terminate, so the entire expression will always be able to provide a result.
However, if you have both effects, then a program may not use an input which does not terminate.
This leads to the choice: if you evaluate the input, then the entire program does not terminate, but if you do not then the program can provide a result.

With this insight, we can turn the choice between strictness and laziness into a choice of interactions between a \emph{monadic} effect and a \emph{comonadic} effect.
There are two ways that a monad and comonad can interact without more structure: \emph{layering} the monad over the comonad, or vice versa.
Applying those constructions in this situation, we discover that they treat the interactions of the effects like a race.
Layering the monad over the comonad lets the monad ``go first:'' we first consider whether an input fails to terminate and, if it does, the entire program fails to terminate.
Thus, it acts like a strict language.
Layering the comonad over the monad lets the comonad ``go first:'' we first consider whether a program fails to use an input and, if it does, then it does not look at whether its input terminates.
Thus, it acts like a lazy language.

However, most languages do not use only strict or lazy behaviors.
Instead, they default to one behavior, but allow a programmer to strategically choose the other strategy.
In current work, I am exploring the semantics of such languages.
To do this, we consider programs which may produce outputs either strictly or lazily, and may consume inputs strictly or lazily.
Composing strict outputs with strict inputs (or lazy outputs with lazy inputs) works exactly as in the strict-only or lazy-only case.
However, to switch from one to the other requires an extra mathematical object called a \emph{distributive law}.
\fi

\section*{Future Work}

Going into the future, I will continue not only to develop these threads of research separately, but also to combine them using their shared modal foundations.
This development will include the development of concrete languages, of abstract models, and of verification techniques.
Not only do these styles of research each pose their own challenges and rewards, but each also inspires more development in the others.

Concrete languages allow us to explore the design space of languages and logics while also holding the possibility of impact via adoption.
Going forward, I plan to continue to build new logics and programming languages with strong guarantees.
For instance, I am currently working on building and proving secure an authorization logic which contains the logical features necessary to state practical security policies.
Moreover, I plan on extending Pirouette in several directions, such as by adding the ability to interact with \emph{client} processes which are not controlled by the program author.
By adding such practically-minded extensions, and working with more-applied collaborators, these languages can solve important problems throughout computing.

Using abstract models of languages, we can develop libraries of theorems which can be applied to new concrete language designs.
So far, my work in this direction has focused on information-flow control, but this is not fundamental: I have built models describing issues in programming-language design which do not focus on security at all~\citep{HirschT18}.
Going forward, building such models of authorization logics and choreographic programs could bring many of the same benefits to those domains that I discussed for information-flow control.
I'm particularly interested in understanding how the language of messages can affect the properties of a choreographic language.
By parameterizing Pirouette's design on the message language, I have already begun to build general models; future models will be more abstract, allowing them to be applied outside Pirouette.

Finally, verification techniques give a toolbox for programmers who want to prove their programs secure and correct.
Coq libraries such as the interaction-trees library, are a promising method for applying abstract models to verification.
This style also holds promise for authorization policies: Coq libraries and metaprogramming facilities could make proving that systems enforce authorization policies using authorization logics realistic.
Language design also has a significant role to play here.
In particular, I plan to use the similarities between authorization logics and choreographic programming to build a tool for verifying concurrent programs.

\bibliography{bibliography/main}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% eval: (setenv "TEXINPUTS" ".::$TEXMF/tex/::./latex-pl-syntax/")
%%% End:
